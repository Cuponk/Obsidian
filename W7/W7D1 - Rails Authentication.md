
--- 

- The web relies on **session tokens** as the DB can't track the current user
-  A user is considered 'logged in' when the server session token matches the session token that is generated by the user
- A logout happens when a user token is unmatched from the rails session token

---

### Learning Objectives

- Be able to explain how user passwords are securely stored in a database using hashing + salting
- Be able to explain how we can keep users logged in across requests/page visits? (session)
- Understand how to securely store passwords in DB using BCrypt
- Implement sign up, login, and log out functionality using `session` and `params`

---

![[Pasted image 20230703093132.png]]

---

## Authentication

- Users need to be able to have unique sessions on our websites
- To achieve this, users will need:
    - a password that is private and secure, and
    - a randomly generated, unique token to act as a session identifier
- The password will need to be saved in the database in some form
- The session token will also be saved in the database, and temporarily stored on the user's browser

---

### Session Tokens

- HTTP is stateless (request/response cycles don't retain information)
- Need to keep track of a login session on the browser , so we save a token in a cookie
- A cookie is a small piece of data that our app can temporarily store on the user's browser
- When logged in, the token in the cookie will match the token in our DB
- When logged out, there will be no match

Note:
- If students would like to learn more - they can read here: [https://guides.rubyonrails.org/security.html](https://guides.rubyonrails.org/security.html)

---
### Four Key Principals of #Hashing
- **One Way** - given an input, we can easily produce the output but not vice versa
- **Deterministic** - same input, same output every time
- **Uniform** - reduce the amount of possible **hash collisions**
    - Pigeon-hole problem
- **Sensitive** - a small change to the input results in an entirely different hash

---
**Rainbow table**

![[Pasted image 20230703093712.png]]

---

### #Salting

- Adds entropy to common passwords by pairing them with a random string of characters or numbers (i.e. the salt) ad generates the hash form that
- Make it computationally unfeasible to brute force hashed password, or use a rainbow table, even for the most common passwords
- Need to store the salt along with the hash in the DB
- Adding a salt to a password is known as the password digest
- i.e. password = '1234'
- i.e. salt = '3jc3a'
- password digest is a hashed version of '12343jc3a'
- Used for duplicate password

---

### #BCrypt

- One-way hashing function
- Incorporates a `salt` to prevent hash/rainbow attacks
- Slower relative to other hashing algorithms like MD5, SHA-2 (this is good)
- Adaptive, scales with computational power, resistant to brute-force
- Verifies if two hashes were created from the same input without needing to reveal them
- Not exclusive to Ruby or Rails- many languages have implementations
- Include the `bcrypt` gem in `Gemfile` to use in Ruby project

---
## User Schema

|column name|data type|details|
|---|---|---|
|`id`|integer|not null, primary key|
|`username`|string|not null, indexed, unique|
|`password_digest`|string|not null|
|`session_token`|string|not null, indexed, unique|

---

### New Gems

- `better_errors`
	- Different (nicer looking) error page
	- Full stack trace
	- Source line in editor
- `binding_of_caller`
	- Enables extra features in `better_errors`
	- REPL on error page
	- Local and Instance Variable inspection
	- We won't use this on its own (only with `better_errors`)

---

### 3 Key Auth Functionalities

- Sign up new users
- Login existing users
- Logout existing users

---
## Sign Up

#### Relevant Routes for Sign Up

- Sign up
	- `get /'users/new', to: 'users#new'`
	- `post '/users', to: 'users#create'`
- `resources :users, only: [:new, :create]`

#### How do we 'Sign Up' a user?

1. Pass params (`username`, `password`) through a form
2. Create a new instance of a user with these params
3. Try to save the user in the database
    - User needs `password_digest` and `session_token` attributes
4. Login, redirect, show errors, etc.

#### Sign Up Methods
- SPIRE is a acronym of sign up methods
- SPIRE is written in the User model
S - `Self.find_by_credentials(username, password)`
P - `password=(password)`
I - `is_password?(password)`
R - `reset_session_token`
E - `ensure_session_token`

>[!Self.find_by_credentials]-
>```ruby
>def Self.find_by_credentials(username, password)
>	# gonna find user by username
>	user = User.find_by(username: username)
>	if user && user.is_password?(password)
>		# if found, return password
>		return user
>	else
>		# if not found || password is bad
>		return nil
>	end
>end
>```

>[!password=]-
>```ruby
># we make setter because no column, rails makes setter and getter for each column
>def password=(password)
>	@password = password
>	# set password instance variable
>	# hijack this method
>	# self setter!!
>	Self.password_digest = BCrypt::Password.create(password)
>end
>```

>[!is_password?]-
>```ruby
># used in self.find_by_credentials
>def is_password(password)
>	bcryptObj = BCrypt::Password.new(self.password_digest)
>	# we create BCrypt object to use library
>	bcryptObj.is_password?(password)
>	# NOT RECURSION - different method in BCrypt library
>end
>```

>[!reset_session_token]-
>```ruby
def reset_session_token!
>	# generate_session_token is a helper method
>	self.session_token = generate_session_token
>	# change session_token for user
>	self.save!
>	# then save user again
>	return session_token
>	# return current users session token
>end
>```

>[!ensure_session_token]-
>```ruby
># this will run before any validations
>def ensure_session_token
>	self.session_token ||= generate_session_token
>end
>```

---

CRRLLL (single C, double R, tripple L)
- Written in ApplicationController
C - current_user
R - require_logged_in
R - require_logged_out
L - logged_in?
L - login
L - logout

>[!current_user]-
>```ruby
>def current_user
>	# `session` is given by rails similar to params
>	# allows us to interact w/ session_token in client/browser/cookies
>	# find_by takes in column name and the session hash generated by ruby
>@current_user ||= User.find_by(session_token:  session[:session_token])
>end
>```

>[!require_logged_in]-
>```ruby
>def require_logged_in
> # redirect user unless they are logged in
>  redirect_to new_session_url unless logged_in?
>  # redirect to login form unless logged in
>end
>```

>[!redirect_logged_out]-
>```ruby
>def require_logged_out
>	# redirect if logged in
>	redirect_to users_url if logged_in? # users_url can be whatever
>end
>```

>[!logged_in?]-
>```ruby
>#returns boolean
>def logged_in?
>	!!current_user
>end
>```

>[!login(user)]-
>```ruby
>def login(user)
>	# this is where we force the session tokens to match
>	session[:session_token]= user.reset_session_token!
>end
>```

>[!logout]-
>```ruby
>def logout
> 	# goal is to unmatch session_tokens
> 	current_user.reset_session_token! if logged_in?
> 	session[:session_token] = nil
> 	@current_user = nil
> end
>```

---

## Login

#### Relevant Routes for Login

- Login
    - `get '/session/new', to: 'session#new'`
    - `post '/session', to: 'session#create'`

```ruby
# config/routes.rb
# note - singular resource
resource :session, only: [:new, :create] 
```
- resource is used rather than resources to not use wild cards

#### How do we 'Login' a user?

- Database does not know anything about who is logged in
- The 'logged in' status depends on `cookies`
- The controller modifies our `cookies` using the `session`
- A user is logged in if

```ruby
user.session_token == session[:session_token]
```

---

#### What is the rails `session` object?

- Hash-like object that we can add key-value pairs to, allowing for a nice interface to manage cookies on our site and allow data to persist across request-response cycles (remember _HTTP is stateless_)
- Created under the hood by `ActionController::Base` for every request that comes in (note that it is _lazily loaded_)
- Sends cookies back down to the browser with each response (browser sends them back up with each request)
- Only available in controllers and views

---
#### What is #session 

- Hash-like object that we can add key-value pairs to, allowing for a nice interface to manage cookies on our site and allow data to persist across request-response cycles (remember _HTTP is stateless_)
- Created under the hood by `ActionController::Base` for every request that comes in (note that it is _lazily loaded_)
- Sends cookies back down to the browser with each response (browser sends them back up with each request)
- Only available in controllers and views

---

## Logout

#### Relevant Routes for Logout

- Logout
	- `delete '/session', to: 'session#destroy'`

```ruby
# config/routes.rb
# note resource = singular
resource :session, only: [:destroy]
```

#### How do we 'Logout' a user?

Remember, a user is logged in if:

```ruby
    user.session_token == session[:session_token]
```

Therefore, we need to:

- reset the user's session token
- nilify session's session token

---

### Demo notes

- users will now contain password digest and session token

>[!generate_unique_session_token]-
>```ruby
>def generate_unique_session_token
>	token = SecureRandom::urlsafe_base64
>	while User.exists?(session_token: token)
>		token = SecureRandom::urlsafe_base64
>	end
>	token
>end
>```


- this is a helper method
- `ensure_session_token` must be run before validation
- to achieve this write `before_validation :ensure_session_token`

